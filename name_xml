
import os
import re
from lxml import etree
from pathlib import Path

# Константы для настройки
INPUT_XML_FILE = "dataset.xml"  # Путь к входному XML файлу
OUTPUT_FOLDER = "output_files"  # Папка для сохранения результатов
MAX_FILES_TO_CREATE = 1000      # Максимальное количество создаваемых файлов

def clean_invalid_xml_chars(text):
    """
    Удаляет невалидные XML символы из текста
    """
    # Регулярное выражение для нахождения невалидных XML символов
    invalid_xml_re = re.compile(
        '[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]'
    )
    return invalid_xml_re.sub('', text)

def remove_empty_lines(text):
    """
    Удаляет пустые строки из текста
    """
    # Разделяем текст на строки, фильтруем пустые и объединяем обратно
    lines = text.splitlines()
    non_empty_lines = [line.strip() for line in lines if line.strip()]
    return '\n'.join(non_empty_lines)

def process_xml_file():
    """
    Основная функция для обработки XML файла и создания текстовых файлов
    """
    # Проверяем существование входного файла
    if not os.path.exists(INPUT_XML_FILE):
        print(f"Ошибка: Файл {INPUT_XML_FILE} не найден!")
        return

    # Создаем выходную папку если она не существует
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)
    
    # Счетчик созданных файлов
    files_created = 0
    
    try:
        # Пытаемся прочитать и очистить XML файл
        with open(INPUT_XML_FILE, 'r', encoding='utf-8') as file:
            content = file.read()
        
        # Очищаем от невалидных XML символов
        cleaned_content = clean_invalid_xml_chars(content)
        
        # Парсим XML с обработкой ошибок
        parser = etree.XMLParser(recover=True, encoding='utf-8')
        root = etree.fromstring(cleaned_content.encode('utf-8'), parser)
        
        # Обработка XML (пример - измените под свою структуру)
        for i, element in enumerate(root):
            if files_created >= MAX_FILES_TO_CREATE:
                break
                
            # Пример обработки элемента - создание файла с текстом элемента
            try:
                text_content = etree.tostring(element, encoding='unicode', method='text')
                text_content = text_content.strip()
                
                # Удаляем пустые строки
                text_content = remove_empty_lines(text_content)
                
                if text_content:  # Проверяем, что содержимое не пустое
                    # Создаем файл
                    output_file = os.path.join(OUTPUT_FOLDER, f"output_{files_created + 1}.txt")
                    with open(output_file, 'w', encoding='utf-8') as f:
                        f.write(text_content)
                    
                    files_created += 1
                    print(f"Создан файл: {output_file}")
                    
            except Exception as e:
                print(f"Ошибка при обработке элемента {i}: {e}")
                continue
                
        print(f"Успешно создано {files_created} файлов.")
        
    except etree.XMLSyntaxError as e:
        print(f"Ошибка синтаксиса XML: {e}")
        # Показываем контекст ошибки
        try:
            with open(INPUT_XML_FILE, 'r', encoding='utf-8') as file:
                lines = file.readlines()
                error_line = e.position[0]
                start = max(0, error_line - 3)
                end = min(len(lines), error_line + 2)
                
                print(f"Контекст ошибки (строки {start+1}-{end}):")
                for i in range(start, end):
                    marker = ">>> " if i + 1 == error_line else "    "
                    print(f"{marker}{i+1}: {lines[i].strip()}")
        except:
            print("Не удалось показать контекст ошибки.")
            
    except UnicodeDecodeError:
        print("Ошибка кодировки файла. Пробуем альтернативные кодировки...")
        # Пробуем разные кодировки
        encodings = ['cp1251', 'iso-8859-1', 'cp1252']
        for encoding in encodings:
            try:
                with open(INPUT_XML_FILE, 'r', encoding=encoding) as file:
                    content = file.read()
                
                cleaned_content = clean_invalid_xml_chars(content)
                parser = etree.XMLParser(recover=True, encoding=encoding)
                root = etree.fromstring(cleaned_content.encode(encoding), parser)
                print(f"Файл успешно прочитан с кодировкой {encoding}")
                # Дальнейшая обработка...
                break
            except Exception as e:
                print(f"Кодировка {encoding} не подошла: {e}")
                continue
        else:
            print("Не удалось определить кодировку файла.")
            
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")

if __name__ == "__main__":
    process_xml_file()

import os
import re
from lxml import etree
from pathlib import Path

# Константы для настройки
INPUT_XML_FILE = "dataset.xml"  # Путь к входному XML файлу
OUTPUT_FOLDER = "output_files"  # Папка для сохранения результатов
MAX_FILES_TO_CREATE = 1000      # Максимальное количество создаваемых файлов

def fix_xml_file(file_path):
    """
    Функция для предварительной очистки XML файла от возможных проблем
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Убираем непечатаемые символы
        content = re.sub(r'[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]', '', content)
        
        # Заменяем проблемные символы в тексте
        content = content.replace('&', '&amp;')
        content = content.replace('<', '&lt;')
        content = content.replace('>', '&gt;')
        content = content.replace('"', '&quot;')
        content = content.replace("'", '&apos;')
        
        # Временный файл для очищенного содержимого
        temp_file = file_path + '.cleaned.xml'
        with open(temp_file, 'w', encoding='utf-8') as f:
            f.write(content)
        
        return temp_file
        
    except Exception as e:
        print(f"Ошибка при очистке файла: {e}")
        return file_path

def process_xml_file():
    """
    Основная функция для обработки XML файла и создания текстовых файлов
    """
    # Проверяем существование входного файла
    if not os.path.exists(INPUT_XML_FILE):
        print(f"Ошибка: Файл {INPUT_XML_FILE} не найден!")
        return
    
    # Создаем папку для выходных файлов, если она не существует
    output_path = Path(OUTPUT_FOLDER)
    output_path.mkdir(exist_ok=True)
    
    # Пытаемся сначала прочитать оригинальный файл
    original_file = INPUT_XML_FILE
    use_cleaned = False
    
    try:
        # Пробуем прочитать оригинальный файл
        tree = etree.parse(original_file)
        print("Успешно прочитан оригинальный файл")
        
    except etree.XMLSyntaxError as e:
        print(f"Ошибка синтаксиса в оригинальном файле: {e}")
        print("Пытаюсь очистить файл...")
        
        # Пробуем очистить файл
        cleaned_file = fix_xml_file(original_file)
        use_cleaned = True
        original_file = cleaned_file
        
        try:
            tree = etree.parse(cleaned_file)
            print("Успешно прочитан очищенный файл")
        except etree.XMLSyntaxError as e2:
            print(f"Ошибка синтаксиса после очистки: {e2}")
            print("Пытаюсь использовать восстановительный парсер...")
            
            # Используем восстановительный парсер
            parser = etree.XMLParser(recover=True)
            with open(cleaned_file, 'r', encoding='utf-8') as f:
                content = f.read()
            root = etree.fromstring(content, parser)
            tree = etree.ElementTree(root)
            print("Успешно использован восстановительный парсер")
    
    try:
        if 'tree' not in locals():
            # Если tree еще не создан, создаем его с восстановительным парсером
            parser = etree.XMLParser(recover=True)
            with open(original_file, 'r', encoding='utf-8') as f:
                content = f.read()
            root = etree.fromstring(content, parser)
            tree = etree.ElementTree(root)
        
        root = tree.getroot()
        
        # Находим все элементы description (разные возможные варианты)
        descriptions = []
        
        # Пробуем разные XPath выражения
        xpath_expressions = [
            '//description',
            './/description',
            '//DESCRIPTION',
            './/DESCRIPTION',
            '//*[local-name()="description"]'
        ]
        
        for xpath in xpath_expressions:
            found = root.xpath(xpath)
            if found:
                descriptions.extend(found)
                print(f"Найдено {len(found)} элементов с XPath: {xpath}")
                break
        
        if not descriptions:
            print("Не найдено ни одного элемента description. Проверьте структуру XML.")
            return
        
        file_count = 0
        
        for i, description in enumerate(descriptions):
            # Проверяем лимит файлов
            if file_count >= MAX_FILES_TO_CREATE:
                print(f"Достигнут лимит в {MAX_FILES_TO_CREATE} файлов. Остановка обработки.")
                break
            
            # Получаем текст из description
            description_text = ''
            if description.text:
                description_text = description.text.strip()
            else:
                # Пробуем получить текст из всех дочерних элементов
                description_text = ''.join(description.itertext()).strip()
            
            if description_text:
                # Создаем имя файла
                filename = f"description_{i+1:04d}.txt"
                filepath = output_path / filename
                
                # Сохраняем в файл
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(description_text)
                
                file_count += 1
                
                if file_count % 100 == 0:
                    print(f"Обработано {file_count} файлов...")
        
        print(f"Готово! Создано {file_count} файлов в папке '{OUTPUT_FOLDER}'")
        
        # Удаляем временный очищенный файл, если он использовался
        if use_cleaned and os.path.exists(original_file) and original_file.endswith('.cleaned.xml'):
            os.remove(original_file)
            
    except Exception as e:
        print(f"Произошла ошибка при обработке: {e}")
        import traceback
        traceback.print_exc()

def debug_xml_structure():
    """
    Функция для отладки структуры XML файла
    """
    try:
        with open(INPUT_XML_FILE, 'r', encoding='utf-8') as f:
            first_lines = ''.join([next(f) for _ in range(10)])
        print("Первые 10 строк файла:")
        print(first_lines)
        
        # Пробуем прочитать и показать структуру
        parser = etree.XMLParser(recover=True)
        with open(INPUT_XML_FILE, 'r', encoding='utf-8') as f:
            content = f.read()
        root = etree.fromstring(content, parser)
        
        print("\nКорневой элемент:", root.tag)
        print("Дочерние элементы:")
        for child in root[:5]:  # Показываем первые 5 дочерних элементов
            print(f"  - {child.tag}")
            for subchild in child[:3]:  # Показываем первые 3 внучатых элемента
                print(f"    * {subchild.tag}")
        
    except Exception as e:
        print(f"Ошибка при отладке: {e}")

if __name__ == "__main__":
    print("Запуск обработки XML файла...")
    
    # Если нужна отладка структуры файла
    # debug_xml_structure()
    
    process_xml_file()